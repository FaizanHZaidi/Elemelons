using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Photon;

public class PlayerBehavior : Photon.MonoBehaviour {

	protected string flameType;
    protected Color playerColor;
	public float health;
	int cameraID;

	protected string[] flameOptions = new string[5] {"yellow", "blue", "green", "purple", "white"};

	void Awake() {
		DontDestroyOnLoad (this.gameObject);
	}

    void Start () {
		// Initialize health and healthbar:
		health = 100f;
		gameObject.GetComponentInChildren<HealthBar>().player = gameObject;

        // Pick a random, saturated and not-too-dark color
        playerColor = Random.ColorHSV(0f, 1f, 1f, 1f, 0.5f, 1f); // Results in an RGBA value.
        // Create a Vector3 to package the RGB values to be send serialized:
        Vector3 serializedColor;
        serializedColor.x = playerColor.r;
        serializedColor.y = playerColor.g;
        serializedColor.z = playerColor.b;
        // Run a Remote Procedure Call for only currently connected users, sending the values to SetColor:
        PhotonView.Get(this).RPC("SetColor", PhotonTargets.All, serializedColor);
		PhotonView.Get (this).RPC ("UpdateHealth", PhotonTargets.All, health);
		flameType = flameOptions[(int) Random.Range(0,4)];
		Debug.Log ("FlameChoice is" + flameType);
		cameraID = GameObject.Find("Camera (eye)").GetInstanceID();
    }

	void Update() {
		// Broken respawn code:
		if (health <= 0f) {
			Destroy (gameObject.GetComponentInParent<Camera>());
			GameObject.Find ("NetworkManager").GetComponent<Network> ().OnJoinedRoom ();
			// Delete all the old player stuff
			health = 100f;
		}
	}

    [PunRPC] // As a photon serialized view, only send floats/ints/vectors/quaternions.
    public void SetColor(Vector3 color)
    {
        // Sets this Player to the color sent with the call:
        GetComponent<Renderer>().material.color = new Color(color.x, color.y, color.z, 1f);
        playerColor = GetComponent<Renderer>().material.color;
        if (PhotonView.Get(this).isMine)
        { // If this user called the function, send this call to the other users, including those who join:
            photonView.RPC("SetColor", PhotonTargets.OthersBuffered, color);
        }
    }

	[PunRPC]
	public void UpdateHealth(float newHealth) {
		health = newHealth;
//		if (PhotonNetwork.isMasterClient) {
//			PhotonNetwork.Destroy (gameObject);
//			// This will have to do more, accounting for resetting the camera and all...
//		}
	}

	// When something hits the player:
	void OnCollisionEnter(Collision other) {
		//Debug.Log("Player collided with " + other.gameObject);

		if (other.gameObject.CompareTag ("boulder")) {
			health -= 20f;
			PhotonView.Get (this).RPC ("UpdateHealth", PhotonTargets.All, health);
			Debug.Log ("You were hit by a boulder! Health: " + health);
		}

		// Ignore further collisions if they were generated by this client: (Not how this works)
//		if (photonView.isMine) {
//			return; // Return would always be called, since 'this' player is always the clients.
//		}

		if(other.gameObject.CompareTag("fireball")) {
			if (other.gameObject.GetComponent<FireballBehavior> ().playerID != cameraID) {
				health -= 25f;
				PhotonView.Get (this).RPC ("UpdateHealth", PhotonTargets.All, health);
				Debug.Log ("You were hit by a fireball! Health: " + health);
			}
		}
	}

	void OnParticleCollision(GameObject particles) {
		Debug.Log (particles);
		if(particles.CompareTag("flamethrower")) {
			Debug.Log ("You are hit by a flamethrower!");
			health -= 10f*Time.deltaTime; 
		}
	}
		
}